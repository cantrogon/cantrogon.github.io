<div id="output"></div>
<form id="properties">
	Dimensions: <select id="dimensions">
		<option value="0">Image 1</option>
		<option value="1">Image 2</option>
		<option value="2">Custom</option>
	</select><br/>
	Width: <input id="w" type="number" min="1" value="600" required disabled><br/>
	Height: <input id="h" type="number" min="1" value="600" required disabled><br/>
	Automatic Contrast: <input id="autoContrast" type="checkbox" checked>
	<span id="autoContrastValue"></span><br/>
	Contrast Value: <input id="contrastValue" type="number" min="0" value="1" step="any" required disabled><br/>
	<input id="reverseBackdrops" type="button" value="Reverse Backdrops"><br/>
	Picture 1: <br/>
	Backdrop: <input id="color1" type="color" value="#000000"><br/>
	Image: <input id="img1" type="file" accept="image/*" required><br/>
	Fit: <select id="fit1">
		<option value="0">Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel1">
		<option value="3">Average</option>
		<option value="0">Red</option>
		<option value="1">Green</option>
		<option value="2">Blue</option>
	</select><br/>
	Invert: <input id="invert1" type="checkbox"><br/>
	Picture 2: <br/>
	Backdrop: <input id="color2" type="color" value="#ffffff"><br/>
	Image: <input id="img2" type="file" accept="image/*" required><br/>
	Fit: <select id="fit2">
		<option value="0">Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel2">
		<option value="3">Average</option>
		<option value="0">Red</option>
		<option value="1">Green</option>
		<option value="2">Blue</option>
	</select><br/>
	Invert: <input id="invert2" type="checkbox"><br/>
	<input id="submit" type="submit">
	<input id="reset" type="reset">
	<br/><br/><div id="loading"></div>
</form>

<style type="text/css">
	
#output {
	width: 600px;
	height: 1200px;
	float: left;
}

#output canvas {
	width: 100%;
}

#loading {
	display: none;
	width: 20px;
	height: 20px;
	background: black;
	animation: spin 5s linear infinite;
}

@keyframes spin {
	to {transform: rotate(360deg);}
}

</style>

<script type="text/javascript">

var p = {}
var defaultP = {
	w: 600,
	h: 600,
	dimensions: 0,
	autoContrast: true,
	contrastValue: 1,
	autoContrastValue: 0,
	side: [{
		color: [0,0,0],
		fit: 0,
		channel: 3,
		invert: false
	},{
		color: [255,255,255],
		fit: 0,
		channel: 3,
		invert: false
	}]
}

var data = [];

var output = document.getElementById('output');
var c = [new Canvas(defaultP.w,defaultP.h,output), new Canvas(defaultP.w,defaultP.h,output)]

var ins = {}, insImgs, changedData = [], changedImgs = [], changedCanvas;

function resetProperties() {
	p = JSON.parse(JSON.stringify(defaultP));
}

function Canvas(w,h,elm=null) {
	var canvas = document.createElement('canvas'),
		ctx = canvas.getContext('2d');
	canvas.width = w;
	canvas.height = h;
	if (elm)
		elm.appendChild(canvas)
	
	this.canvas = canvas;
	this.ctx = ctx;
}

function updateCanvasBackdrops() {
	for (var i = c.length - 1; i >= 0; i--) {
		c[i].canvas.style.background = arrToRgb(p.side[i].color);
	}
}

window.addEventListener('load',function() {
	loadHandler();
})

function loadHandler() {
	resetProperties();
	setForm();
	setAutoContrastLabel();
}

function setForm() {
	var inputs = [
		...document.querySelectorAll('input:not([type=file]):not([type=button]):not([type=submit]):not([type=reset])'),
		...document.getElementsByTagName('select')
	]

	inputs.forEach(elm => {
		ins[elm.id] = {
			elm: elm,
			type: elm.tagName === "INPUT" ? elm.type : "select",
			id: elm.id.match(/\D+/)[0],
			n: elm.id.match(/\d/) ? elm.id.match(/\d/)[0] - 1 : null,
			// children: elm.children,
			disable: function() {
				this.elm.disabled = true;	
			},
			enable: function() {
				this.elm.disabled = false;	
			},
			getValue: function() {
				switch (this.type) {
					case "checkbox":
						return this.elm.checked;
					case "select":
					case "number":
						return parseInt(this.elm.value);
					case "color":
						return hexToRgb(this.elm.value);
					default:
						return this.elm.value;
				}
			},
			getProp: function() {
				return this.n === null
					? p[this.id]
					: p.side[this.n][this.id];
			},
			matchProp: function() {
				var v = this.getValue(), p = this.getProp();
				return this.type === "color"
					? v.every((x,i) => x === p[i])
					: v === p;
			},
			setProp: function() {
				var v = this.getValue();
				if (this.n === null)
					p[this.id] = v;
				else
					p.side[this.n][this.id] = v;
			}
			// setVal: function() {
			// 	if (this.type === "checkbox" && n === null)
			// 		this.elm.checked = p[this.id];
			// 	else if (this.type === "checkbox")
			// 		this.elm.checked = p[this.n][this.id];
			// 	else if (this.type === "number")
			// 		this.elm.value = p[this.id];
			// 	else if (true) {}
			// 		p.side[this.n][this.id] = this.getVal();
			// }
		}

	})


	var insFits = document.querySelectorAll('select[id^=fit]');

	insImgs = document.querySelectorAll('input[type=file]');
	for (var k = insImgs.length - 1; k >= 0; k--) {
		insImgs[k].num = k;
		insImgs[k].addEventListener('change', function(){if (this.value !== "") changedImgs[this.num] = true});
		// insFits[k].num = k;
		// insFits[k].addEventListener('change', function(){changedData[this.num] = true;});
	}

	document.getElementById('reverseBackdrops').addEventListener('click', function(e) {
		e.preventDefault();
		var col1 = document.getElementById('color1')
		var col2 = document.getElementById('color2')
		var temp = col2.value;
		col2.value = col1.value;
		col1.value = temp;
	})

	var dimensions = document.getElementById('dimensions');
	var sels = dimensions.children;	

	ins.autoContrast.elm.addEventListener('change', function() {
		if (this.checked)
			ins.contrastValue.disable();
		else
			ins.contrastValue.enable();
	})

	ins.dimensions.elm.addEventListener('change', function() {
		if (this.value === "2") {
			ins.w.enable();
			ins.h.enable();
		} else {
			ins.w.disable();
			ins.h.disable();
		}
	})

	document.getElementById('reset').addEventListener('click', e => {
		ins.contrastValue.disable();
		ins.w.disable();
		ins.h.disable();
	})

	document.getElementById('properties').addEventListener('submit', e => {
		e.preventDefault();
		sumbitHandler();
	})

}

function updateDimensions(n=2) {
	if (n !== 2) {
		p.w = p.side[n].img.width;
		p.h = p.side[n].img.height;
	}

	for (var i = 1; i >= 0; i--) {
		c[i].canvas.width = p.w;
		c[i].canvas.height = p.h;
	}
	changedData = [true,true];
}

function updateProperties() {
	Object.keys(ins).forEach((k,i) => {
		var v = ins[k].getValue();
		if (!ins[k].elm.disabled) {
			ins[k].setProp();
			if (ins[k].id === "fit" && !ins[k].matchProp())
				changedData[ins[k].n] = true;
		}
	})
}

function loadingStart() {
	console.log("START")
	document.getElementById('loading').style.display = "inline-block";
}

function loadingEnd() {
	console.log("END")
	document.getElementById('loading').style.display = "none";
}

function sumbitHandler() {

	loadingStart();

	var num = changedImgs.filter(x => x === true).length, counter = 0, doData = [];
	if (changedImgs.includes(true)) {
		changedImgs.forEach((x,i) => {
			if (x) {
				doData[i] = true;
				var img = new Image();
				img.src = URL.createObjectURL(insImgs[i].files[0])
				p.side[i].img = img;
			    img.addEventListener("load", function() {
				    URL.revokeObjectURL(this.src);
				    loadImg();
				})
			}
		})
		changedImgs = [];
	} else {
		contThing();
	}

	function loadImg() {
		counter++;
		if (counter === num) {
			contThing();
		}
	}

	function contThing(argument) {
		updateProperties();
		updateCanvasBackdrops();
		updateDimensions(p.dimensions);

		for (var i = 1; i >= 0; i--) {
			if (doData[i] || changedData[i])
				data[i] = getImgData(i);
		}
		changedData = [];
		
		drawData();

		setAutoContrastLabel();

		loadingEnd();
	}
}

function setAutoContrastLabel() {
	document.getElementById('autoContrastValue').innerText = p.autoContrastValue.toFixed(2);
}




function drawData() {
	var imgData = c[0].ctx.createImageData(p.w,p.h);
	imgData.data.set(getData());
	c[0].ctx.putImageData(imgData,0,0)
	c[1].ctx.putImageData(imgData,0,0)
}

function getData() {
	var newData = new Uint8ClampedArray(p.w*p.h*4);

	var minAvg = 0, lum = [];
	for (var i = 0; i < newData.length; i+=4) {
		// get initial luminosities
		// lum[i] = [];
		// for (var j = 0; j < 2; j++) {
		// 	var raw = [data[j][i],data[j][i+1],data[j][i+2]];
		// 	lum[i][j] = p.side[j].channel === 3 
		// 		? raw.reduce((p,c) => p+c)/3/255 
		// 		: raw[p.side[j].channel]/255;
		// 	if (p.side[j].invert)
		// 		lum[i][j] = 1-lum[i][j];
		// }

		// // get value for auto contrast
		// var l1 = lum[i][0], l2 = lum[i][1];

// var l1 =  p.side[0].channel === 3 ? [data[0][i],data[0][i+1],data[0][i+2]].reduce((p,c) => p+c)/3/255 : 0;
// var l2 =  p.side[1].channel === 3 ? [data[1][i],data[1][i+1],data[1][i+2]].reduce((p,c) => p+c)/3/255 : 0;

		for (var j = 0; j < 2; j++) {
			var raw = [data[j][i],data[j][i+1],data[j][i+2]];
			lum[j] = p.side[j].channel === 3 
				? raw.reduce((p,c) => p+c)/3/255 
				: raw[p.side[j].channel]/255;
			if (p.side[j].invert)
				lum[j] = 1-lum[j];
		}
		var l1 = lum[0], l2 = lum[1];
// var l1 = data[0][i]/255;
// var l2 = data[1][i]/255;
		if ((l1+1-l2)/2 > minAvg) minAvg = (l1+1-l2)/2;
		// if (l1-l2 > minAvg) minAvg = l1-l2;
// minAvg = data[0][i]/255;
// minAvg2 = data[1][i]/255;
		// newData[i]   = minAvg * 255;
		// newData[i+1]   = minAvg * 255;
		// newData[i+2]   = minAvg * 255;
		// newData[i+3]   = 255;

		// lum[i][0] = l1;
		// lum[i][1] = l2;
	}

	// get value for auto contrast
	p.autoContrastValue = Math.min(1/minAvg,2);
	var cval = p.autoContrast ? p.autoContrastValue : p.contrastValue;

// if (false)
	for (var i = 0; i < newData.length; i+=4) {

// var l1 = data[0][i]/255;
// var l2 = data[1][i]/255;
		for (var j = 0; j < 2; j++) {
			var raw = [data[j][i],data[j][i+1],data[j][i+2]];
			lum[j] = p.side[j].channel === 3 
				? raw.reduce((p,c) => p+c)/3/255 
				: raw[p.side[j].channel]/255;
			if (p.side[j].invert)
				lum[j] = 1-lum[j];
		}
		var l1 = lum[0], l2 = lum[1];
		// var l1 = lum[i][0], l2 = lum[i][1];

		// seperate luminosities
		l1 /= 2;
		l2 = (l2 + 1) / 2;

		// change contrast
		l1 *= cval;
		l2 = 1 - (1-l2) * cval;

		// get final alpha and luminosity
		function getLum(x,y) {return x / (1 - y + x);}
		function getAlp(x,y) {return 1 - y + x;}

		var l = getLum(l1,l2);
		var fl = [l,l,l];
		var fa = getAlp(l1,l2);

		// backdrop colors
		function setBackdrops(l,c1,c2) {return (c2 - c1) * l + c1}
		fl = fl.map((x,i) => setBackdrops(x,p.side[0].color[i]/255,p.side[1].color[i]/255))

		fl = fl.map(x => x*255);
		newData[i]   = fl[0];
		newData[i+1] = fl[1];
		newData[i+2] = fl[2];
		newData[i+3] = fa*255;
	}

	return newData;
}

function getImgData(i) {
	return imgData(i,p.side[i].img,p.side[i].fit,p.side[i].invert);
}

function imgData(back,img,fit,invert) {
	var w = p.w, h = p.h,
		canvas = new Canvas(w,h),
		ctx = canvas.ctx;

	// image fit
	var iw, ih;
	if (fit < 2) {
		var ratioOut = w/h;
		var ratioIn = img.width/img.height;
		var isVert = ratioIn < ratioOut;
		if (fit === 1) isVert = !isVert;
		if (isVert) {ih = h; iw = ih*ratioIn;}
		else {iw = w; ih = iw/ratioIn;}
	} else {
		iw = w;
		ih = h;
	}

	if (invert) back = !back;

	if (back) ctx.fillStyle = "#ffffff";
	else ctx.fillStyle = "#000000";
	ctx.fillRect(0,0,w,h);

	ctx.drawImage(img,(w-iw)/2,(h-ih)/2,iw,ih);

	// document.body.appendChild(canvas);
	// document.body.appendChild(img);

	return ctx.getImageData(0,0,p.w,p.h).data
}

function arrToRgb(arr) {
	return "rgb("+arr[0]+","+arr[1]+","+arr[2]+")";
}

function hexToRgb(str) {
	return str.match(/[A-Za-z0-9]{2}/g).map(function(x) {return parseInt(x,16)})
}

</script>