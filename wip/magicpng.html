<div id="output"></div>
<form id="properties">
	Dimensions: <select id="dimensions">
		<option value="0" selected>Image 1</option>
		<option value="1">Image 2</option>
		<option value="2">Overlay Image</option>
		<option value="3">Custom</option>
	</select><br/>
	Width: <input id="width" type="number" min="1" value="600"><br/>
	Height: <input id="height" type="number" min="1" value="600"><br/>
	<input id="reverseBackdrops" type="button" value="Reverse Backdrops"><br/>
	<!-- <button id="reverseBackdrops">Reverse Backdrops</button><br/> -->
	Automatic Contrast: <input id="autoContrast" type="checkbox"><span id="autoContrastValue">1.4</span><br/>
	Contrast Value: <input id="contrastValue" type="number" min="0" value="1" step="any"><br/>
	Picture 1: <br/>
	Backdrop: <input id="color1" type="color" value="#000000"><br/>
	Image: <input id="img1" type="file" accept="image/*"><br/>
	Fit: <select id="fit1">
		<option value="0" selected>Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel1">
		<option value="3" selected>Average</option>
		<option value="0">0</option>
		<option value="1">1</option>
		<option value="2">2</option>
	</select><br/>
	Invert: <input id="invert1" type="checkbox"><br/>
	Picture 2: <br/>
	Backdrop: <input id="color2" type="color" value="#ffffff"><br/>
	Image: <input id="img2" type="file" accept="image/*"><br/>
	Fit: <select id="fit2">
		<option value="0" selected>Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel2">
		<option value="3" selected>Average</option>
		<option value="0">0</option>
		<option value="1">1</option>
		<option value="2">2</option>
	</select><br/>
	Invert: <input id="invert2" type="checkbox"><br/>
	Overlay: <br/>
	Do Overlay: <input id="doOverlay" type="checkbox"><br/>
	Overlay Density: <input id="density" type="number" value="0.2" step="any"><br/>
	Color Overlay: <input id="doColor" type="radio" name="overlay" checked><br/>
	Color: <input id="color3" type="color" value="#ff0000"><br/>
	Image Overlay: <input id="doImage" type="radio" name="overlay"><br/>
	Image: <input id="img3" type="file" accept="image/*"><br/>
	Fit: <select id="fit3">
		<option value="0" selected>Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Invert: <input type="checkbox" id="invert3"><br/>
	<input type="submit">
	<input type="reset">
</form>

<style type="text/css">
	
#output {
	width: 600px;
	height: 1200px;
	float: left;
}

canvas {
	width: 100%;
}

</style>

<script type="text/javascript">

function updateDimensions(n=3) {
	if (n !== 3) {
		w = side[n].img.width;
		h = side[n].img.height;
	}

	for (var i = c.length - 1; i >= 0; i--) {
		c[i].canvas.width = w;
		c[i].canvas.height = h;
	}
	changedData = [true,true,true];
	defaultData = [new Uint8ClampedArray(w*h*4), new Uint8ClampedArray(w*h*4).fill(255)];
}

function updateProperties(elm) {
	var id = elm.id.match(/\D+/)[0],
		n = elm.id.match(/\d/) ? elm.id.match(/\d/)[0] - 1 : null,
		v = elm.value,
		c = elm.checked;

	if (v !== "")
	switch (id) {
		case "width":
			w = v;
			// updateDimensions();
			break;
		case "height":
			h = v;
			// updateDimensions();
			break;
		case "contrastValue":
			contrastValue = v;
			break;
		case "density":
			side[2].density = v;
			break;
		case "dimensions":
			updateDimensions(parseInt(v));
			break;
		case "fit":
			side[n].fit = parseInt(v);
			break;
		case "channel":
			side[n].channel = parseInt(v);
			break;
		case "autoContrast":
			autoContrast = c;
			break;
		case "invert":
			side[n].invert = c;
			break;
		case "doOverlay":
			side[2].doOverlay = c;
			break;
		case "doImage":
			side[2].doImage = c;
			break;
		case "color":
			side[n].color = hexToRgb(v);
			break;
	}
}

var w = 600, h = 600,
	autoContrast = false,
	contrastValue = 0,
	side = [{},{},{}],
	data = [];
var defaultData = [new Uint8ClampedArray(w*h*4), new Uint8ClampedArray(w*h*4).fill(255)];

function Canvas(elm,w,h) {
	var canvas = document.createElement('canvas'),
		ctx = canvas.getContext('2d');
	canvas.width = w;
	canvas.height = h;
	elm.appendChild(canvas)
	
	this.canvas = canvas;
	this.ctx = ctx;
}

function updateCanvasBackdrops() {
	for (var i = c.length - 1; i >= 0; i--) {
		c[i].canvas.style.background = arrToRgb(side[i].color);
	}
}

var output = document.getElementById('output');
var c = [new Canvas(output,w,h), new Canvas(output,w,h)]

var ins, insImgs, changedData = [], changedImgs = [], changedCanvas;

function loadHandler() {
	setForm();
	// ins.forEach(x => updateProperties(x))
	// updateCanvasBackdrops();
}

function setForm() {
	ins = [
		...document.querySelectorAll('input:not([type=file]):not([type=button]):not([type=submit]):not([type=reset])'),
		...document.getElementsByTagName('select')
	]
	insImgs = document.querySelectorAll('input[type=file]');
	var insFits = document.querySelectorAll('select[id^=fit]');

	for (var k = insImgs.length - 1; k >= 0; k--) {
		insImgs[k].num = k;
		insImgs[k].addEventListener('change', function(){if (this.value !== "") changedImgs[this.num] = true});
		insFits[k].num = k;
		insFits[k].addEventListener('change', function(){changedData[this.num] = true;});
	}

	document.getElementById('reverseBackdrops').addEventListener('click', function(e) {
		e.preventDefault();
		var col1 = document.getElementById('color1')
		var col2 = document.getElementById('color2')
		var temp = col2.value;
		col2.value = col1.value;
		col1.value = temp;
	})

	var dimensions = document.getElementById('dimensions');
	var sels = dimensions.children;	
	sels[3].selected = true;
	// sels[2].disabled = true;
}


document.getElementById('properties').addEventListener('submit', e => {
	e.preventDefault();
	sumbitHandler();
})

window.addEventListener('load',function() {
	loadHandler();
})

function sumbitHandler() {

	// ins.forEach(x => updateProperties(x))
	// updateCanvasBackdrops();

	var num = changedImgs.filter(x => x === true).length, counter = 0, doData = [];
	if (changedImgs.includes(true)) {
		changedImgs.forEach((x,i) => {
			if (x) {
				doData[i] = true;
				var img = new Image();
				img.src = URL.createObjectURL(insImgs[i].files[0])
				side[i].img = img;
				img.num = i;
			    img.addEventListener("load", function() {
				    URL.revokeObjectURL(this.src);
				    changedImgs[this.num] = false;
				    loadImg();
				})
			}
		})
		changedImgs = [];
	} else {
		contThing();
	}

	function loadImg() {
		counter++;
		if (counter === num) {
			contThing();
		}
	}

	function contThing(argument) {
		ins.forEach(x => updateProperties(x))
		updateCanvasBackdrops();
		
		for (var i = 2; i >= 0; i--) {
			if (insImgs[i].value === "")
				data[i] = defaultData[i];
			else if (doData[i] || changedData[i])
				data[i] = imgData(i,side[i].img,side[i].fit);
		}
		changedData = [];
		
		drawData();
	}
}




function drawData() {
	var imgData = c[0].ctx.createImageData(w,h);
	imgData.data.set(getData());
	c[0].ctx.putImageData(imgData,0,0)
	c[1].ctx.putImageData(imgData,0,0)
}

function getData() {
	var newData = new Uint8ClampedArray(w*h*4);
	var overlay = side[2];

	var minAvg = 0, lum = [];
	for (var i = 0; i < newData.length; i+=4) {
		// get initial luminosities
		lum[i] = [];
		for (var j = 0; j < 2; j++) {
			var raw = [data[j][i],data[j][i+1],data[j][i+2]];
			lum[i][j] = side[j].channel === 3 
				? raw.reduce((p,c) => p+c)/3/255 
				: raw[side[j].channel]/255;
			if (side[j].invert)
				lum[i][j] = 1-lum[i][j];
		}

		// get value for auto contrast
		var l1 = lum[i][0], l2 = lum[i][1];
		if ((l1+1-l2)/2 > minAvg) minAvg = (l1+1-l2)/2;
	}

	// get value for auto contrast
	var autoCval = Math.min(1/minAvg,2);
	var cval = autoContrast ? autoCval : contrastValue;
	document.getElementById('autoContrastValue').innerText = autoCval;

	for (var i = 0; i < newData.length; i+=4) {
		var l1 = lum[i][0], l2 = lum[i][1];

		// seperate luminosities
		var density = overlay.density;
		if (!overlay.doOverlay) density = 0;
		var gap = (1 - density) / 2, gapl = density;
		l1 = l1*gap;
		l2 = (l2+1)*gap;

		// change contrast
		l1 *= cval;
		l2 = 1 - (1-l2) * cval;

		// get final alpha and luminosity
		function getAL(x,y) {
			var a = 1-(y-x); 
			var l = x/(1-(y-x));
			return {a:a,l:l}
		}

		var al = getAL(l1,l2), a = al.a, l = al.l;
		var fl = [l,l,l];

		// color overlay
		if (overlay.doOverlay && !(data[2] === undefined && overlay.doImage)) {
			var lay;
			if (overlay.doImage) {
				lay = [data[2][i],data[2][i+1],data[2][i+2]];
				if (overlay.invert)
					lay = lay.map(x => 255-x);
			} else
				lay = overlay.color;
			fl = fl.map((x,i) => getAL(l1 + lay[i]/255 * gapl, l2 + lay[i]/255 * gapl).l);
		}

		// backdrop colors
		fl = fl.map((x,i) => (side[1].color[i]/255 - side[0].color[i]/255) * x + side[0].color[i]/255)

		fl = fl.map(x => x*255)
		newData[i]   = fl[0];
		newData[i+1] = fl[1];
		newData[i+2] = fl[2];
		newData[i+3] = a*255;
	}

	return newData;
}

function imgData(back,img,fit) {
	var canvas = document.createElement("canvas");
	var ctx = canvas.getContext("2d");
	canvas.width = w;
	canvas.height = h;

	// image fit
	var iw, ih;
	if (fit < 2) {
		var ratioOut = w/h;
		var ratioIn = img.width/img.height;
		var isVert = ratioIn < ratioOut;
		if (fit === 1) isVert = !isVert;
		if (isVert) {ih = h; iw = ih*ratioIn;}
		else {iw = w; ih = iw/ratioIn;}
	} else {
		iw = w;
		ih = h;
	}

	if (back === 1) ctx.fillStyle = "#ffffff";
	else ctx.fillStyle = "#000000";

	ctx.fillRect(0,0,w,h);
	ctx.drawImage(img,(w-iw)/2,(h-ih)/2,iw,ih);

	// document.body.appendChild(canvas);
	// document.body.appendChild(img);

	return ctx.getImageData(0,0,w,h).data
}

function arrToRgb(arr) {
	return "rgb("+arr[0]+","+arr[1]+","+arr[2]+")";
}

function hexToRgb(str) {
	return str.match(/[A-Za-z0-9]{2}/g).map(function(x) {return parseInt(x,16)})
}

</script>