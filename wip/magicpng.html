<h1 id="heading">MagicPNG - Opacity-based image merging</h1>
<form id="properties">
	Dimensions: <select id="dimensions">
		<option selected>Image 1</option>
		<option>Image 2</option>
		<option>Custom</option>
	</select><br/>
	Width: <input id="w" type="number" min="1" max="32767" value="600" required disabled><br/>
	Height: <input id="h" type="number" min="1" max="32767" value="600" required disabled><br/>
	Automatic Contrast: <input id="autoContrast" type="checkbox" checked>
	<span id="autoContrastValue">0.00</span><br/>
	Contrast Value: <input id="contrastValue" type="number" min="0" value="0.5" step="any" required disabled><br/>
	<input id="reverseBackdrops" type="button" value="Reverse Backdrops"><br/>
	<br/>
	Image 1: <br/>
	Backdrop: <input id="color1" type="color" value="#000000"><br/>
	File: <input id="img1" type="file" accept="image/*" required><br/>
	Fit: <select id="fit1">
		<option selected>Contain</option>
		<option>Fill</option>
		<option>Stretch</option>
	</select><br/>
	Grayscale: <select id="grayscale1">
		<option>Average</option>
		<option selected>Luma</option>
		<option>Desaturated</option>
		<option>Red</option>
		<option>Green</option>
		<option>Blue</option>
		<option>Min</option>
		<option>Max</option>
	</select><br/>
	Invert: <input id="invert1" type="checkbox"><br/>
	<br/>
	Image 2: <br/>
	Backdrop: <input id="color2" type="color" value="#ffffff"><br/>
	File: <input id="img2" type="file" accept="image/*" required><br/>
	Fit: <select id="fit2">
		<option selected>Contain</option>
		<option>Fill</option>
		<option>Stretch</option>
	</select><br/>
	Grayscale: <select id="grayscale2">
		<option>Average</option>
		<option selected>Luma</option>
		<option>Desaturated</option>
		<option>Red</option>
		<option>Green</option>
		<option>Blue</option>
		<option>Min</option>
		<option>Max</option>
	</select><br/>
	Invert: <input id="invert2" type="checkbox"><br/>
	<br/>
	Overlay: <br/>
	Do Overlay: <input id="doOverlay" type="checkbox"><br/>
	Color: <input id="colorOverlay" type="color" value="#ff0000" disabled><br/>
	Density: <input id="densityOverlay" type="number" min="0" value="0.5" step="any" required disabled><br/>
	<br/>
	<input id="submit" type="submit">
	<input id="reset" type="reset">
	<br/><br/><a id="download" href="#" download>download</a>
	<br/><br/><div id="loading"></div>
</form>
<div id="output"></div>

<style type="text/css">

#properties {
	float: left;
}
	
#output {
	width: 1200px;
	max-width: 100%;
	float: right;
}

#output canvas {
	width: calc(50% - 20px);
	float: left;
	border: 10px solid black;
}

#loading {
	display: none;
	width: 30px;
	height: 30px;
	box-sizing: border-box;
	border: 5px solid black;
	border-top-color: transparent;
	border-radius: 50%;
	animation: spin 5s linear infinite;
}

@keyframes spin {
	to {transform: rotate(360deg);}
}

#download {
	visibility: hidden;
}

input[type=color]:disabled {
	background: #dcdcd0;
}

</style>

<script type="text/javascript">

let p = {side: [{},{}]}, data = [], c, ins = {}, insImgs, changedImgs = [], downloadOn, calcRunnning;

window.addEventListener('load',function() {
	loadHandler();
})

function loadHandler() {
	setCanvases();
	setForm();
	updateProperties();
	updateCanvasBackdrops();
}

function Canvas(w,h,elm=null) {
	let canvas = document.createElement('canvas'),
		ctx = canvas.getContext('2d');
	canvas.width = w;
	canvas.height = h;
	if (elm)
		elm.appendChild(canvas)
	
	this.canvas = canvas;
	this.ctx = ctx;
}

function setCanvases() {
	let output = document.getElementById('output');
	c = [new Canvas(1,1,output), new Canvas(1,1,output)]
}

function updateCanvasBackdrops() {
	for (let i = c.length - 1; i >= 0; i--) {
		c[i].canvas.style.background = arrToRgb(p.side[i].color);
	}
}

function setForm() {
	let inputs = [
		...document.querySelectorAll('input:not([type=file]):not([type=button]):not([type=submit]):not([type=reset])'),
		...document.getElementsByTagName('select')
	]

	inputs.forEach(elm => {
		ins[elm.id] = {
			elm: elm,
			type: elm.tagName === "INPUT" ? elm.step !== "any" ? elm.type : "numberf" : "select",
			id: elm.id.match(/\D+/)[0],
			n: elm.id.match(/\d/) ? elm.id.match(/\d/)[0] - 1 : null,
			disable: function() {
				this.elm.disabled = true;
			},
			enable: function() {
				this.elm.disabled = false;	
			},
			getValue: function() {
				switch (this.type) {
					case "checkbox":
						return this.elm.checked;
					case "select":
						return this.elm.selectedIndex;
					case "number":
						return parseInt(this.elm.value);
					case "numberf":
						return parseFloat(this.elm.value)
					case "color":
						return hexToRgb(this.elm.value);
					default:
						return this.elm.value;
				}
			},
			setProp: function() {
				let v = this.getValue();
				if (this.n === null)
					p[this.id] = v;
				else
					p.side[this.n][this.id] = v;
			}
		}
	})

	insImgs = document.querySelectorAll('input[type=file]');
	for (let i = 1; i >= 0; i--) {
		insImgs[i].num = i;
		insImgs[i].addEventListener('change', function(){
			if (this.value !== "") changedImgs[this.num] = true;
		});
	}

	document.getElementById('reverseBackdrops').addEventListener('click', function(e) {
		e.preventDefault();
		let temp = ins.color1.elm.value;
		ins.color1.elm.value = ins.color2.elm.value;
		ins.color2.elm.value = temp;
	})

	ins.autoContrast.elm.addEventListener('change', function() {
		if (this.checked)
			ins.contrastValue.disable();
		else
			ins.contrastValue.enable();
	})

	ins.dimensions.elm.addEventListener('change', function() {
		if (this.selectedIndex === 2) {
			ins.w.enable();
			ins.h.enable();
		} else {
			ins.w.disable();
			ins.h.disable();
		}
	})

	ins.doOverlay.elm.addEventListener('change', function() {
		if (this.checked) {
			ins.colorOverlay.enable();
			ins.densityOverlay.enable();
		} else {
			ins.colorOverlay.disable();
			ins.densityOverlay.disable();
		}
	})

	document.getElementById('reset').addEventListener('click', e => {
		setFormDisabled();
	})

	document.getElementById('properties').addEventListener('submit', e => {
		e.preventDefault();
		if (!calcRunnning) sumbitHandler();
	})
}

function setFormDisabled() {
	ins.contrastValue.disable();
	ins.w.disable();
	ins.h.disable();
	ins.colorOverlay.disable();
	ins.densityOverlay.disable();
}

function updateDimensions() {
	let n = p.dimensions;

	if (n !== 2) {
		p.w = p.side[n].img.width;
		p.h = p.side[n].img.height;
	}

	for (let i = 1; i >= 0; i--) {
		c[i].canvas.width = p.w;
		c[i].canvas.height = p.h;
	}
}

function updateProperties() {
	Object.keys(ins).forEach(k => {
		if (!ins[k].elm.disabled)
			ins[k].setProp();
	})
}

function loadingStart() {
	console.log("START")
	document.getElementById('loading').style.display = "inline-block";
	calcRunnning = true;
}

function loadingEnd() {
	console.log("END")
	document.getElementById('loading').style.display = "none";
	document.getElementById('autoContrastValue').innerText = p.autoContrastValue.toFixed(2);
	if (!downloadOn) {
		document.getElementById('download').style.visibility = "visible";
		downloadOn = true;
	}
	document.getElementById('download').href = c[0].canvas.toDataURL();
	calcRunnning = false;
}

function loadImage(url,callback) {
	let image = new Image();
	image.src = url;
	image.onload = callback;
	return image;
}

function sumbitHandler() {
	loadingStart();

	let num = changedImgs.filter(x => x).length;
	if (num) {
		changedImgs.forEach((x,i) => {
			if (x)
				loadImage(URL.createObjectURL(insImgs[i].files[0]), function() {
					p.side[i].img = this;
					URL.revokeObjectURL(this.src);
					onImageLoad();
				});
		});
		changedImgs = [];
	} else {
		proceed();
	}

	function onImageLoad() {
		if (--num === 0)
			proceed();
	}

	function proceed() {
		setTimeout(function() {
			updateProperties();
			updateDimensions();
			updateCanvasBackdrops();
			setImgData();
			drawData();
			loadingEnd();
		},0)
	}
}

function setImgData() {
	for (let i = 1; i >= 0; i--) {
		data[i] = imgData(i,p.side[i].img,p.side[i].fit,p.side[i].invert);
	}
}

function drawData() {
	let imgData = c[0].ctx.createImageData(p.w,p.h);
	imgData.data.set(getData());
	c[0].ctx.putImageData(imgData,0,0)
	c[1].ctx.putImageData(imgData,0,0)
}

function getGrayscale(type,r,g,b) {
	switch (type) {
		case 0:
			return (r + g + b) / 3;
		case 1:
			return r * 0.2126 + g * 0.7152 + b * 0.0722;
		case 2:
			return (Math.max(r,g,b) + Math.min(r,g,b)) / 2;
		case 3:
			return r;
		case 4:
			return g;
		case 5:
			return b;
		case 6:
			return Math.min(r,g,b);
		case 7:
			return Math.max(r,g,b);
	}
}

function getLums(i) {
	// get initial luminosities
	let lum = [];
	for (let j = 0; j < 2; j++) {
		let raw = [data[j][i],data[j][i+1],data[j][i+2]].map(x => x / 255);
		lum[j] = getGrayscale(p.side[j].grayscale,...raw);
		if (p.side[j].invert)
			lum[j] = 1 - lum[j];
	}
	return lum;
}

// necessary functions
function getLum(x,y) {return x / (1 - y + x)}
function getAlp(x,y,c=0.5) {return (1 - y + x) * c}
function getOverlayLum(l,a,cl,ca,fa) {
	if (a === 0) return cl;
	return (cl * ca + l * a * (1 - ca)) / fa
}
function getOverlayAlp(a,ca) {return ca + a * (1 - ca)}
function setBackdrops(l,c1,c2) {return (c2 - c1) * l + c1}

function getData() {
	let newData = new Uint8ClampedArray(p.w*p.h*4), 
		len = newData.length;

	// get value for auto contrast
	let maxDiff = 0;
	for (let i = 0; i < len; i += 4) {
		let l = getLums(i), l1 = l[0], l2 = l[1];
		if (l1 - l2 > maxDiff) maxDiff = l1 - l2;
	}
	p.autoContrastValue = 1 / (maxDiff + 1);
	let cval = p.autoContrast ? p.autoContrastValue : p.contrastValue;

	// main loop
	for (let i = 0; i < len; i += 4) {
		let lums = getLums(i), l1 = lums[0], l2 = lums[1];

		// new luminosities
		let l = getLum(l1,l2), fl = [l,l,l];
		let a = getAlp(l1,l2,cval);

		// backdrop colors
		fl = fl.map((x,i) => setBackdrops(x, p.side[0].color[i]/255, p.side[1].color[i]/255));

		// overlay
		if (p.doOverlay) {
			let fa = getOverlayAlp(a, p.densityOverlay);
			fl = fl.map((x,i) => getOverlayLum(x, a, p.colorOverlay[i]/255, p.densityOverlay, fa));
			a = fa;
		}

		// set values
		fl = fl.map(x => x*255);
		newData[i]   = fl[0];
		newData[i+1] = fl[1];
		newData[i+2] = fl[2];
		newData[i+3] = a * 255;
	}

	return newData;
}

function imgData(back,img,fit,invert) {
	let w = p.w, h = p.h,
		canvas = new Canvas(w,h),
		ctx = canvas.ctx;

	// fit image
	let iw, ih;
	if (fit < 2) {
		let ratioOut = w / h;
		let ratioIn = img.width / img.height;
		let isVert = ratioIn < ratioOut;
		if (fit === 1) isVert = !isVert;
		if (isVert) {ih = h; iw = ih * ratioIn;}
		else {iw = w; ih = iw / ratioIn;}
	} else {iw = w; ih = h;}

	// invert backgrounds
	if (invert) back = !back;

	// set backgrounds
	if (back) ctx.fillStyle = "#ffffff";
	else ctx.fillStyle = "#000000";
	ctx.fillRect(0,0,w,h);

	ctx.drawImage(img,(w-iw)/2,(h-ih)/2,iw,ih);

	// document.body.appendChild(canvas);
	// document.body.appendChild(img);

	return ctx.getImageData(0,0,w,h).data
}

function arrToRgb(arr) {
	return "rgb("+arr[0]+","+arr[1]+","+arr[2]+")";
}

function hexToRgb(str) {
	return str.match(/[A-Za-z0-9]{2}/g).map(function(x) {return parseInt(x,16)})
}

function callMultitask(callback,len,split,incr) {
	var n = Math.ceil(len / split);
	var p = len % split || split;
	for (var i = 0; i < n; i++) {
		var end = i === n - 1 ? i * split + p - 1 : (i + 1) * split - 1;
		setTimeout(splitIteration.bind(null, callback, i * split, end, incr), 0)
	}
}

function splitIteration(callback,start,end,incr=1) {
	for (var i = start; i <= end; i += incr) {
		callback(i)
	}
}

</script>