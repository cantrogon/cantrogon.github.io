<div id="output"></div>
<form id="properties">
	Dimensions: <select id="dimensions">
		<option value="0">Image 1</option>
		<option value="1">Image 2</option>
		<option value="2">Custom</option>
	</select><br/>
	Width: <input id="w" type="number" min="1" max="32767" value="600" required disabled><br/>
	Height: <input id="h" type="number" min="1" max="32767" value="600" required disabled><br/>
	Automatic Contrast: <input id="autoContrast" type="checkbox" checked>
	<span id="autoContrastValue">0.00</span><br/>
	Contrast Value: <input id="contrastValue" type="number" min="0" value="0.5" step="any" required disabled><br/>
	<input id="reverseBackdrops" type="button" value="Reverse Backdrops"><br/>
	Picture 1: <br/>
	Backdrop: <input id="color1" type="color" value="#000000"><br/>
	Image: <input id="img1" type="file" accept="image/*" required><br/>
	Fit: <select id="fit1">
		<option value="0">Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel1">
		<option value="3">Average</option>
		<option value="0">Red</option>
		<option value="1">Green</option>
		<option value="2">Blue</option>
	</select><br/>
	Invert: <input id="invert1" type="checkbox"><br/>
	Picture 2: <br/>
	Backdrop: <input id="color2" type="color" value="#ffffff"><br/>
	Image: <input id="img2" type="file" accept="image/*" required><br/>
	Fit: <select id="fit2">
		<option value="0">Contain</option>
		<option value="1">Fill</option>
		<option value="2">Stretch</option>
	</select><br/>
	Channel: <select id="channel2">
		<option value="3">Average</option>
		<option value="0">Red</option>
		<option value="1">Green</option>
		<option value="2">Blue</option>
	</select><br/>
	Invert: <input id="invert2" type="checkbox"><br/>
	<input id="submit" type="submit">
	<input id="reset" type="reset">
	<br/><br/><a id="download" href="#" download>download</a>
	<br/><br/><div id="loading"></div>
</form>

<style type="text/css">
	
#output {
	width: 600px;
	min-height: 100%;
	float: left;
	margin-right: 15px;
}

#output canvas {
	width: 100%;
}

#loading {
	display: none;
	width: 30px;
	height: 30px;
	box-sizing: border-box;
	border: 5px solid black;
	border-top-color: transparent;
	border-radius: 50%;
	animation: spin 5s linear infinite;
}

@keyframes spin {
	to {transform: rotate(360deg);}
}

#download {
	visibility: hidden;
}

</style>

<script type="text/javascript">

var p = {side: [{},{}]}, data = [], c, ins = {}, insImgs, changedImgs = [], downloadOn;

window.addEventListener('load',function() {
	loadHandler();
})

function loadHandler() {
	setCanvases();
	setForm();
	updateProperties();
	updateCanvasBackdrops();
}

function Canvas(w,h,elm=null) {
	var canvas = document.createElement('canvas'),
		ctx = canvas.getContext('2d');
	canvas.width = w;
	canvas.height = h;
	if (elm)
		elm.appendChild(canvas)
	
	this.canvas = canvas;
	this.ctx = ctx;
}

function setCanvases() {
	var output = document.getElementById('output');
	c = [new Canvas(1,1,output), new Canvas(1,1,output)]
}

function updateCanvasBackdrops() {
	for (var i = c.length - 1; i >= 0; i--) {
		c[i].canvas.style.background = arrToRgb(p.side[i].color);
	}
}

function setForm() {
	var inputs = [
		...document.querySelectorAll('input:not([type=file]):not([type=button]):not([type=submit]):not([type=reset])'),
		...document.getElementsByTagName('select')
	]

	inputs.forEach(elm => {
		ins[elm.id] = {
			elm: elm,
			type: elm.tagName === "INPUT" ? elm.id !== "contrastValue" ? elm.type : "numberf" : "select",
			id: elm.id.match(/\D+/)[0],
			n: elm.id.match(/\d/) ? elm.id.match(/\d/)[0] - 1 : null,
			disable: function() {
				this.elm.disabled = true;	
			},
			enable: function() {
				this.elm.disabled = false;	
			},
			getValue: function() {
				switch (this.type) {
					case "checkbox":
						return this.elm.checked;
					case "select":
					case "number":
						return parseInt(this.elm.value);
					case "numberf":
						return parseFloat(this.elm.value)
					case "color":
						return hexToRgb(this.elm.value);
					default:
						return this.elm.value;
				}
			},
			setProp: function() {
				var v = this.getValue();
				if (this.n === null)
					p[this.id] = v;
				else
					p.side[this.n][this.id] = v;
			}
		}
	})

	insImgs = document.querySelectorAll('input[type=file]');
	for (var i = 1; i >= 0; i--) {
		insImgs[i].num = i;
		insImgs[i].addEventListener('change', function(){
			if (this.value !== "") changedImgs[this.num] = true;
		});
	}

	document.getElementById('reverseBackdrops').addEventListener('click', function(e) {
		e.preventDefault();
		var temp = ins.color1.elm.value;
		ins.color1.elm.value = ins.color2.elm.value;
		ins.color2.elm.value = temp;
	})

	ins.autoContrast.elm.addEventListener('change', function() {
		if (this.checked)
			ins.contrastValue.disable();
		else
			ins.contrastValue.enable();
	})

	ins.dimensions.elm.addEventListener('change', function() {
		if (this.value === "2") {
			ins.w.enable();
			ins.h.enable();
		} else {
			ins.w.disable();
			ins.h.disable();
		}
	})

	document.getElementById('reset').addEventListener('click', e => {
		setFormDisabled();
	})

	document.getElementById('properties').addEventListener('submit', e => {
		e.preventDefault();
		sumbitHandler();
	})
}

function setFormDisabled() {
	ins.contrastValue.disable();
	ins.w.disable();
	ins.h.disable();
}

function updateDimensions() {
	var n = p.dimensions;

	if (n !== 2) {
		p.w = p.side[n].img.width;
		p.h = p.side[n].img.height;
	}

	for (var i = 1; i >= 0; i--) {
		c[i].canvas.width = p.w;
		c[i].canvas.height = p.h;
	}
}

function updateProperties() {
	Object.keys(ins).forEach(k => {
		if (!ins[k].elm.disabled)
			ins[k].setProp();
	})
}

function loadingStart() {
	console.log("START")
	document.getElementById('loading').style.display = "inline-block";
}

function loadingEnd() {
	console.log("END")
	document.getElementById('loading').style.display = "none";
	document.getElementById('autoContrastValue').innerText = p.autoContrastValue.toFixed(2);
	if (!downloadOn) {
		document.getElementById('download').style.visibility = "visible";
		downloadOn = true;
	}
	document.getElementById('download').href = c[0].canvas.toDataURL();
}

function loadImage(url,callback) {
	var image = new Image();
	image.src = url;
	image.onload = callback;
	return image;
}

function sumbitHandler() {
	loadingStart();

	var num = changedImgs.filter(x => x).length;
	if (num) {
		changedImgs.forEach((x,i) => {
			if (x)
				loadImage(URL.createObjectURL(insImgs[i].files[0]), function() {
					p.side[i].img = this;
					URL.revokeObjectURL(this.src);
					onImageLoad();
				});
		});
		changedImgs = [];
	} else {
		proceed();
	}

	function onImageLoad() {
		if (--num === 0)
			proceed();
	}

	function proceed() {
		window.setTimeout(function() {
			updateProperties();
			updateDimensions();
			updateCanvasBackdrops();
			setImgData();
			drawData();
			loadingEnd();
		},0)
	}
}

function setImgData() {
	for (var i = 1; i >= 0; i--) {
		data[i] = imgData(i,p.side[i].img,p.side[i].fit,p.side[i].invert);
	}
}

function drawData() {
	var imgData = c[0].ctx.createImageData(p.w,p.h);
	imgData.data.set(getData());
	c[0].ctx.putImageData(imgData,0,0)
	c[1].ctx.putImageData(imgData,0,0)
}

function getData() {
	var newData = new Uint8ClampedArray(p.w*p.h*4), 
		len = newData.length;

	// get initial luminosities
	function getLums(i) {
		var lum = [];
		for (var j = 0; j < 2; j++) {
			var raw = [data[j][i],data[j][i+1],data[j][i+2]];
			lum[j] = p.side[j].channel === 3 
				? raw.reduce((p,c) => p+c)/3/255 
				: raw[p.side[j].channel]/255;
			if (p.side[j].invert)
				lum[j] = 1 - lum[j];
		}
		return lum;
	}

	// get value for auto contrast
	var maxDiff = 0;
	for (var i = 0; i < len; i += 4) {
		var l = getLums(i), l1 = l[0], l2 = l[1];
		if (l1 - l2 > maxDiff) maxDiff = l1 - l2;
	}
	p.autoContrastValue = 1 / (maxDiff + 1);
	var cval = p.autoContrast ? p.autoContrastValue : p.contrastValue;

	// necessary functions
	function getLum(x,y) {return x / (1 - y + x)}
	function getAlp(x,y) {return (1 - y + x) * cval}
	function setBackdrops(l,c1,c2) {return (c2 - c1) * l + c1}

	// main loop
	for (var i = 0; i < len; i += 4) {
		var lums = getLums(i), l1 = lums[0], l2 = lums[1];

		// new luminosities
		var l = getLum(l1,l2), fl = [l,l,l];

		// backdrop colors
		fl = fl.map((x,i) => setBackdrops(x, p.side[0].color[i]/255, p.side[1].color[i]/255))

		fl = fl.map(x => x*255);
		newData[i]   = fl[0];
		newData[i+1] = fl[1];
		newData[i+2] = fl[2];
		newData[i+3] = getAlp(l1,l2) * 255;
	}

	return newData;
}

function imgData(back,img,fit,invert) {
	var w = p.w, h = p.h,
		canvas = new Canvas(w,h),
		ctx = canvas.ctx;

	// fit image
	var iw, ih;
	if (fit < 2) {
		var ratioOut = w / h;
		var ratioIn = img.width / img.height;
		var isVert = ratioIn < ratioOut;
		if (fit === 1) isVert = !isVert;
		if (isVert) {ih = h; iw = ih * ratioIn;}
		else {iw = w; ih = iw / ratioIn;}
	} else {iw = w; ih = h;}

	// invert backgrounds
	if (invert) back = !back;

	// set backgrounds
	if (back) ctx.fillStyle = "#ffffff";
	else ctx.fillStyle = "#000000";
	ctx.fillRect(0,0,w,h);

	ctx.drawImage(img,(w-iw)/2,(h-ih)/2,iw,ih);

	// document.body.appendChild(canvas);
	// document.body.appendChild(img);

	return ctx.getImageData(0,0,w,h).data
}

function arrToRgb(arr) {
	return "rgb("+arr[0]+","+arr[1]+","+arr[2]+")";
}

function hexToRgb(str) {
	return str.match(/[A-Za-z0-9]{2}/g).map(function(x) {return parseInt(x,16)})
}

</script>